## 前端 IR 定义

前端 IR 的代码在 `frontend::ir`，其组成部分如下：

```
┌─────────┐     ┌──────┐                          
│ Program │     │ Expr │◄──┐                      
└────┬────┘     └──────┘   │                      
     │                     │                      
     │                ┌────┴────┐                 
     │             ┌─►│ VarDecl │                 
     │  ┌────────┐ │  └─────────┘     ┌──────────┐
     └─►│ Module ├─┤               ┌─►│ DeclStmt │
        └────────┘ │  ┌──────────┐ │  └──────────┘
                   ├─►│ FuncDecl ├─┤              
                   │  └──────────┘ │  ┌────────┐  
                   │               ├─►│ IfStmt │  
                   │  ┌─────┐      │  └────────┘  
                   └─►│ ... │      │              
                      └─────┘      │  ┌─────┐     
                                   └─►│ ... │     
                                      └─────┘     
```

为了降低代码的认知复杂度，我重新设计了前端 IR 的语法结构，使其包含更少的实体。这样的前端语法较为自由，例如：

- 没有限制在函数中定义函数
- 没有限制函数返回指针
- ……

## 前端 IR 解析

前端 IR 解析的代码在 `frontend::parse`。

由于使用了重新设计的前端 IR，为了获取语法高亮以及方便的调试体验，我使用 `winnow` 库进行解析。`winnow` 库可以以 token 为单位解析，但这会令码量膨胀，因此我选择直接以字符为单位解析。为了使解析方式等价，我在 `frontend::parse::token` 中确保匹配到的字符和后面的字符不组成新的 token，例如解析 `=` 的时候如果遇到 `==`，会因为 `==` 是一个新的 token 而失败。

为了和 C 语言兼容，前端 IR 会额外解析 `#include` 和 `#define`，其中 `#include` 没有任何用处；`#define` 会被视为常量整数定义，并不是真正的宏。

经过 benchmark，使用上述思路解析相对使用 `lalrpop` 库较快（TODO）。但如果目标是令代码简洁稳定，我个人认为使用 `lalrpop` 库或者其他的 Parser Generator 会更好，现在这些代码尤其是 token 的处理较为丑陋。

## 前端 IR 变换

### 数组变形

数组变形的代码在 `frontend::transform::reshape_array`。

本工程中端 IR 中有多维数组的抽象，但 C 语言的数组语法相对多维数组更为复杂，需要特殊处理才能被中端 IR 正确识别。如果数组中有一个元素根据类型是 `T[N]`，但实际上是 `T`，那么这单个 `T` 及后面 `N - 1` 个元素会被视为一个 `T[N]` 整体。例如，`int x[3][3] = {1, 2, 3, {4}}` 中 `1, 2, 3` 会被视为 `{1, 2, 3}`。

### 常量折叠

常量折叠的代码在 `frontend::transform::constant_fold`。

为了减轻生成中端 IR 的压力，所有常量都会在前端被求值。每生成一个常量都会立刻对其进行数组变形，并将其值存储在 `env` 中，这样后续的常量如果引用本常量，则能方便地求出其值。

这一部分会折叠类型和常量声明中的常量，对于变量的值即使是常量，也不会尝试折叠，因为中端能做这一部分工作。

## 前端 IR 转中端 IR

本部分代码在 `middle::irgen`。

本部分有 `ProgramKit` 和 `FunctionKit` 两个数据结构，其职责如下：

|      | ProgramKit     | FunctionKit     |
| ---- | -------------- | --------------- |
| 负责 | 全局变量，函数 | 局部变量，语句，表达式 |
| 存储 | 环境，程序    | 附加：计数器，函数路由 |

### 函数路由

代码在 `middle::irgen::function_kit`。

路由内容包括：

- 当前函数出口（加指令往这里加）
- break、continue、return 的目的地
- 接受返回值的变量及其类型

### 值的抽象

代码在 `middle::irgen::value`。

为了降低认知复杂度，`ProgramKit` 和 `FunctionKit` 中基本都是前端 IR 的一比一翻译，例如赋值的语法大致是 `lhs.assign(kit, rhs)`。复杂度被封装在 `Value` 结构中，`Value` 是对值的抽象，包含左值（可以被赋值的值，`ReadWrite`），右值（不能被赋值的值，`ReadOnly`）和数组，暴露了以下主要方法：

- `assign`，赋值
- `load`，加载为只读的 `Operand`
- `getelementptr`，取数组元素（由于被取元素的数组只能是左值，实现出来必有 `getelementptr` 指令，由此得名）

同时，以上方法封装了类型的隐式转换，包括：

- 数组和指针互转
  - 数组作为参数时隐式转换为指针
  - 数组参数被取元素时隐式转换为数组
- 基本类型的隐式转换

### SSA

本部分使用 `mem2reg` pass，代码在 `middle::transform::mem2reg`。

上述生成的代码通过 `load` 和 `store` 来修改值，`mem2reg` pass 会消除这些不必要的 `load` 和 `store`，来把数据操作限制在寄存器中。具体的步骤如下：

- 计算支配边界（[参考文献](https://www.cs.tufts.edu/comp/150FP/archive/keith-cooper/dom14.pdf)）
- 对于所有 `store` 指令，在其支配边界的正闭包中插入 `phi`
  - 给支配边界插 `phi`，是因为走或不走 `store` 基本块，支配边界处变量值不同
  - 给支配边界的支配边界插 `phi` 同理
  - 不断循环，直到没有新的节点需要插入 `phi`……
- 深度优先遍历程序，维护各变量的值
  - `load` 和 `phi` 读取当前变量值
  - `store` 改变当前变量值
  - 注意一个节点的 `phi` 需要被处理多次，因此处理完 `phi` 再判断 `visited`
